{"tagline":"An Implementation of generic (polymorphic) lambdas using clang (llvm version 167560 [11/7/12]); based on C++ Portland October 2012 meeting","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"# Generic Lambdas in C++ using Clang\r\n## This is a Toy implementation of Generic Lambdas for C++ based on the [n3418: Proposal for Generic Lambda Expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3418.pdf). \r\n\r\n### This is NOT by any means intended to be a production ready implementation, and almost certainly has bugs that either I have not yet discovered, or bugs that have been reported (thank you in advance for making the effort to do so) and which I am currently working on.  \r\n\r\n### This implementation's raison d'Ãªtre is to encourage developers to play with the generic lambda feature and provide bug reports and feedback to us.  We hope that this will prove useful to the C++ community and help guide us as we work on the next version of our proposal for the C++ Standardization meeting to be held in Bristol (April 2013). \r\n\r\n### The current version (12/2012) implements subproposals 2.1, 2.2, 2.3 and 2.5.\r\n\r\n### 2.1 Allow the type-specifier within a parameter declaration of a lambda to be auto (i.e. auto is mandatory)\r\n    \r\n    auto Sum = [](auto a, decltype(a) b) { return a + b; };\r\n    int i = Sum(3, 4);\r\n    double d = Sum(3.14, 2.77);\r\n\r\n### 2.2 Allow the use of familiar template syntax in lambda expressions\r\n    auto NumElements = []<int N>(auto (&a)[N]) { return N; }; \r\n    int arri[]{1, 2, 3};\r\n    double arrd[]{3.14, 2.77, 6.626};\r\n    auto total = NumElements(arri) + NumElements(arrd);\r\n\r\n### 2.3 Permit a lambda body to be an expression\r\n\r\n    int local = 10;\r\n    auto L = [&](auto a) a + ++local;\r\n\r\n### 2.4 Named Lambda Syntax has NOT been implemented yet\r\n\r\n### 2.5 Autogenerate a conversion to function pointer in captureless generic lambdas\r\n    auto L = [](auto a, decltype(a) b) { return a + b; };\r\n    int (*fp)(int, int) = L;\r\n\r\n### I also used Richard Smith's (@zygoloid) return type deduction patch to allow the following\r\n\r\n    int local = 10;\r\n    auto L = [](auto &a) -> auto& { return a; };\r\n    ++L(local); \r\n\r\n### How to Compile the Code on Windows\r\n1. Checkout the appropriate version of llvm (167560) by following the instructions at : http://clang.llvm.org/get_started.html.  I use TortoiseSVN on windows. Be sure to download the correct version of llvm (167560).  <b> Do NOT checkout anything else except for the correct revision of the llvm snapshot. <b>\r\n2. In the above instructions from the clang website, where it states to checkout clang using subversion (i.e step 3 svn co http://llvm.org/svn/llvm-project/cfe/trunk clang), instead install git (I use TortoiseGit on windows) and clone this repository into the subdirectory clang. For e.g, using the command line when in your-dir/llvm/tools/ try:\r\n  <pre>\r\n    git clone git:/github.com/faisalv/clang-glambda.git clang\r\n  </pre>\r\n3. Then follow the instructions as delineated on clangs website to compile and build clang.\r\n4. Keep in mind that all the development has been done using Visual Studio 2010.\r\n5. Once you have your clang binary, it should be able to compile your code, but on windows, I find myself having to use the interpreter lli.exe to actually execute my clang \"compiled\" code.  So I do the following when trying to compile code in test.cpp:\r\n<pre>\r\n    clang -std=c++1y -c test.cpp -emit-llvm -o test.bc\r\n    lli test.bc\r\n</pre>\r\n\r\n### How to use the Windows binaries:\r\n1. I have uploaded my most recent Debug build of generic-lambda-clang that was built using visual studio 2010.\r\n2. In order for you to use it, you need certain debug dlls that I can not legally post here - An easy way is probably for you to install [Visual C++ 2010 Express (free)](http://www.microsoft.com/visualstudio/eng/downloads#d-express-windows-desktop).\r\n3. Download the windows executable [generic-lambda-clang.exe]\r\n(https://www.sugarsync.com/pf/D6969703_69613999_6754006) along with the [llvm interpreter: lli.exe](https://www.sugarsync.com/pf/D6969703_65299173_039062) if you need it.\r\n<pre>\r\n    generic-lambda-clang -std=c++1y -c test.cpp -emit-llvm -o test.bc\r\n    lli test.bc\r\n</pre>\r\n4. FYI: lli does cause bugs with executing the following code:  (This appears to be a bug with lli.exe and last I checked also occurred with the actual clang snapshot and has nothing to do with my changes).  The bug does not occur if you are on a platform that can compile the code natively.\r\n<pre>\r\ntemplate<class F1, class F2>\r\nstruct overload : F1, F2 {\r\n  overload(F1 const& f1, F2 const& f2)\r\n   : F1(f1), F2(f2) { }\r\n  using F1::operator();\r\n  using F2::operator();\r\n};\r\ntemplate<class F1, class F2>\r\noverload<F1, F2> make_overload(F1 const& f1, F2 const& f2) {\r\n  return overload<F1, F2>(f1, f2);\r\n}\r\nint main() {\r\n  auto f1 = [&](int i) { return i; }; \r\n  auto f2 = [&](...) { return 0; };\r\n  auto f = make_overload(f1, f2);\r\n  printf(\"%d\\n\", f(5));\r\n  printf(\"%d\\n\", f(3.14));\r\n}\r\n</pre>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","name":"Generic Lambdas in C++ using Clang"}